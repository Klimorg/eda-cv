{"config":{"indexing":"full","lang":["fr"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome on eda-cv documentation This API summarizes some useful function when doing Exeploratory Data Analysis with images. Right now, the endpoints avalaible in the API are : Computing the mean and standard deviation of each channel of an RGB image. Computing the color histogram of each channel of an RGB image. Computing the mean image of an image dataset. Computing a mean vs std scatterplot of an image dataset. How to use it A docker image has been made available on DockerHub . To use it, Download the image 1 docker pull vorphus/eda-cv:latest Create a directory named eda-cv (or whatever the name you want). Run the following command. 1 docker run -it --rm --name eda-cv -p 8080 :8080 -v absolute_path_to_eda-cv:/opt vorphus/eda-cv:latest The image will then create 4 directories in eda-cv : A directory named data . A directory named results with 3 subirectories : histograms , mean_image , scatterplots . The data directory is supposed to store the image dataset on which you want to compute the mean image or the mean vs std scatterplot. The results/histograms , results/mean_image , results/scatterplots will store the image resulting of such functions. Attention As of now, this API is in early stage, so the data directory supports only \" one class datasets \". If your dataset has two or more classes, you'll have to do analysis one class at a time. To compute the mean image of an image dataset, all images must have the same height and width .","title":"Accueil"},{"location":"#welcome-on-eda-cv-documentation","text":"This API summarizes some useful function when doing Exeploratory Data Analysis with images. Right now, the endpoints avalaible in the API are : Computing the mean and standard deviation of each channel of an RGB image. Computing the color histogram of each channel of an RGB image. Computing the mean image of an image dataset. Computing a mean vs std scatterplot of an image dataset.","title":"Welcome on eda-cv documentation"},{"location":"#how-to-use-it","text":"A docker image has been made available on DockerHub . To use it, Download the image 1 docker pull vorphus/eda-cv:latest Create a directory named eda-cv (or whatever the name you want). Run the following command. 1 docker run -it --rm --name eda-cv -p 8080 :8080 -v absolute_path_to_eda-cv:/opt vorphus/eda-cv:latest The image will then create 4 directories in eda-cv : A directory named data . A directory named results with 3 subirectories : histograms , mean_image , scatterplots . The data directory is supposed to store the image dataset on which you want to compute the mean image or the mean vs std scatterplot. The results/histograms , results/mean_image , results/scatterplots will store the image resulting of such functions. Attention As of now, this API is in early stage, so the data directory supports only \" one class datasets \". If your dataset has two or more classes, you'll have to do analysis one class at a time. To compute the mean image of an image dataset, all images must have the same height and width .","title":"How to use it"},{"location":"clustering/","text":"Source code of functions used in clustering app.dependancies.embedding_function EmbeddingEngine summary Source code in app/dependancies/embedding_function.py class EmbeddingEngine : \"\"\"_summary_\"\"\" def __init__ ( self , model : EmbeddingsModel , provider : Providers , * args , ** kwargs ) -> None : \"\"\"_summary_ Args: model (EmbeddingsModel): _description_ provider (Providers): _description_ Raises: NotImplementedError: _description_ NotImplementedError: _description_ \"\"\" super () . __init__ ( * args , ** kwargs ) if model == EmbeddingsModel . resnet50v2 : self . model = settings . resnet50v2 else : raise NotImplementedError if provider == Providers . cpu : self . provider = [ settings . cpu ] else : logger . warning ( \"GPU support not implemented, please chose cpu support.\" ) raise NotImplementedError self . loaded_model = rt . InferenceSession ( self . model , providers = self . provider ) def infer ( self , images_paths ) -> np . ndarray : \"\"\"_summary_ Args: images_paths (_type_): _description_ Returns: np.ndarray: _description_ \"\"\" images_list = [ Image . open ( image ) . resize (( 224 , 224 )) for image in images_paths ] images = [ np . asarray ( image , dtype = \"float32\" ) / 255 for image in images_list ] images = np . reshape ( images , ( - 1 , 224 , 224 , 3 )) logits = self . loaded_model . run ([ \"avg_pool\" ], { \"input\" : images }) return logits [ 0 ] def compute_clustering ( self , logits : np . ndarray , mode : ClusteringMode , ) -> np . ndarray : \"\"\"_summary_ Args: logits (np.ndarray): _description_ mode (ClusteringMode): _description_ Returns: np.ndarray: _description_ \"\"\" if mode == ClusteringMode . tsne : clusters = TSNE ( n_components = 2 , learning_rate = \"auto\" , init = \"random\" , ) . fit_transform ( logits ) elif mode == ClusteringMode . umap : reducer = umap . UMAP () clusters = reducer . fit_transform ( logits ) return clusters def plot ( self , logits : np . ndarray , images_paths : List [ Path ], timestamp : str , mode : ClusteringMode , ) -> Path : \"\"\"_summary_ Args: logits (np.ndarray): _description_ images_paths (List[Path]): _description_ timestamp (str): _description_ mode (ClusteringMode): _description_ Returns: Path: _description_ \"\"\" images_labels = [ Path ( image_path ) . parent . stem for image_path in images_paths ] labels_dict = { label : idx for idx , label in enumerate ( sorted ( set ( images_labels ))) } tags = [ labels_dict [ image_label ] for image_label in images_labels ] N = len ( set ( images_labels )) # define the colormap cmap = plt . cm . jet # extract all colors from the .jet map cmaplist = [ cmap ( i ) for i in range ( cmap . N )] # create the new map cmap = cmap . from_list ( \"Custom cmap\" , cmaplist , cmap . N ) plt . figure ( figsize = ( 20 , 20 )) scatter = plt . scatter ( logits [:, 0 ], logits [:, 1 ], c = tags , cmap = cmap ) if mode == ClusteringMode . tsne : plt . title ( \"tSNE scatterplot with ResNet50v2 preprocess\" ) if mode == ClusteringMode . umap : plt . title ( \"UMAP scatterplot with ResNet50v2 preprocess\" ) plt . xlabel ( \"Dimension 1\" ) plt . ylabel ( \"Dimension 2\" ) plt . legend ( handles = scatter . legend_elements ()[ 0 ], labels = sorted ( set ( images_labels )), title = \"Labels\" , ) saved_image_path = Path ( f \" { settings . scatterplots_dir } /tSNE_scatter_ { timestamp } .png\" , ) . resolve () plt . savefig ( saved_image_path ) return saved_image_path __init__ ( self , model , provider , * args , ** kwargs ) special summary Parameters: Name Type Description Default model EmbeddingsModel description required provider Providers description required Exceptions: Type Description NotImplementedError description NotImplementedError description Source code in app/dependancies/embedding_function.py def __init__ ( self , model : EmbeddingsModel , provider : Providers , * args , ** kwargs ) -> None : \"\"\"_summary_ Args: model (EmbeddingsModel): _description_ provider (Providers): _description_ Raises: NotImplementedError: _description_ NotImplementedError: _description_ \"\"\" super () . __init__ ( * args , ** kwargs ) if model == EmbeddingsModel . resnet50v2 : self . model = settings . resnet50v2 else : raise NotImplementedError if provider == Providers . cpu : self . provider = [ settings . cpu ] else : logger . warning ( \"GPU support not implemented, please chose cpu support.\" ) raise NotImplementedError self . loaded_model = rt . InferenceSession ( self . model , providers = self . provider ) compute_clustering ( self , logits , mode ) summary Parameters: Name Type Description Default logits np.ndarray description required mode ClusteringMode description required Returns: Type Description np.ndarray description Source code in app/dependancies/embedding_function.py def compute_clustering ( self , logits : np . ndarray , mode : ClusteringMode , ) -> np . ndarray : \"\"\"_summary_ Args: logits (np.ndarray): _description_ mode (ClusteringMode): _description_ Returns: np.ndarray: _description_ \"\"\" if mode == ClusteringMode . tsne : clusters = TSNE ( n_components = 2 , learning_rate = \"auto\" , init = \"random\" , ) . fit_transform ( logits ) elif mode == ClusteringMode . umap : reducer = umap . UMAP () clusters = reducer . fit_transform ( logits ) return clusters infer ( self , images_paths ) summary Parameters: Name Type Description Default images_paths _type_ description required Returns: Type Description np.ndarray description Source code in app/dependancies/embedding_function.py def infer ( self , images_paths ) -> np . ndarray : \"\"\"_summary_ Args: images_paths (_type_): _description_ Returns: np.ndarray: _description_ \"\"\" images_list = [ Image . open ( image ) . resize (( 224 , 224 )) for image in images_paths ] images = [ np . asarray ( image , dtype = \"float32\" ) / 255 for image in images_list ] images = np . reshape ( images , ( - 1 , 224 , 224 , 3 )) logits = self . loaded_model . run ([ \"avg_pool\" ], { \"input\" : images }) return logits [ 0 ] plot ( self , logits , images_paths , timestamp , mode ) summary Parameters: Name Type Description Default logits np.ndarray description required images_paths List[Path] description required timestamp str description required mode ClusteringMode description required Returns: Type Description Path description Source code in app/dependancies/embedding_function.py def plot ( self , logits : np . ndarray , images_paths : List [ Path ], timestamp : str , mode : ClusteringMode , ) -> Path : \"\"\"_summary_ Args: logits (np.ndarray): _description_ images_paths (List[Path]): _description_ timestamp (str): _description_ mode (ClusteringMode): _description_ Returns: Path: _description_ \"\"\" images_labels = [ Path ( image_path ) . parent . stem for image_path in images_paths ] labels_dict = { label : idx for idx , label in enumerate ( sorted ( set ( images_labels ))) } tags = [ labels_dict [ image_label ] for image_label in images_labels ] N = len ( set ( images_labels )) # define the colormap cmap = plt . cm . jet # extract all colors from the .jet map cmaplist = [ cmap ( i ) for i in range ( cmap . N )] # create the new map cmap = cmap . from_list ( \"Custom cmap\" , cmaplist , cmap . N ) plt . figure ( figsize = ( 20 , 20 )) scatter = plt . scatter ( logits [:, 0 ], logits [:, 1 ], c = tags , cmap = cmap ) if mode == ClusteringMode . tsne : plt . title ( \"tSNE scatterplot with ResNet50v2 preprocess\" ) if mode == ClusteringMode . umap : plt . title ( \"UMAP scatterplot with ResNet50v2 preprocess\" ) plt . xlabel ( \"Dimension 1\" ) plt . ylabel ( \"Dimension 2\" ) plt . legend ( handles = scatter . legend_elements ()[ 0 ], labels = sorted ( set ( images_labels )), title = \"Labels\" , ) saved_image_path = Path ( f \" { settings . scatterplots_dir } /tSNE_scatter_ { timestamp } .png\" , ) . resolve () plt . savefig ( saved_image_path ) return saved_image_path","title":"Clustering"},{"location":"clustering/#source-code-of-functions-used-in-clustering","text":"","title":"Source code of functions used in clustering"},{"location":"clustering/#app.dependancies.embedding_function","text":"","title":"embedding_function"},{"location":"clustering/#app.dependancies.embedding_function.EmbeddingEngine","text":"summary Source code in app/dependancies/embedding_function.py class EmbeddingEngine : \"\"\"_summary_\"\"\" def __init__ ( self , model : EmbeddingsModel , provider : Providers , * args , ** kwargs ) -> None : \"\"\"_summary_ Args: model (EmbeddingsModel): _description_ provider (Providers): _description_ Raises: NotImplementedError: _description_ NotImplementedError: _description_ \"\"\" super () . __init__ ( * args , ** kwargs ) if model == EmbeddingsModel . resnet50v2 : self . model = settings . resnet50v2 else : raise NotImplementedError if provider == Providers . cpu : self . provider = [ settings . cpu ] else : logger . warning ( \"GPU support not implemented, please chose cpu support.\" ) raise NotImplementedError self . loaded_model = rt . InferenceSession ( self . model , providers = self . provider ) def infer ( self , images_paths ) -> np . ndarray : \"\"\"_summary_ Args: images_paths (_type_): _description_ Returns: np.ndarray: _description_ \"\"\" images_list = [ Image . open ( image ) . resize (( 224 , 224 )) for image in images_paths ] images = [ np . asarray ( image , dtype = \"float32\" ) / 255 for image in images_list ] images = np . reshape ( images , ( - 1 , 224 , 224 , 3 )) logits = self . loaded_model . run ([ \"avg_pool\" ], { \"input\" : images }) return logits [ 0 ] def compute_clustering ( self , logits : np . ndarray , mode : ClusteringMode , ) -> np . ndarray : \"\"\"_summary_ Args: logits (np.ndarray): _description_ mode (ClusteringMode): _description_ Returns: np.ndarray: _description_ \"\"\" if mode == ClusteringMode . tsne : clusters = TSNE ( n_components = 2 , learning_rate = \"auto\" , init = \"random\" , ) . fit_transform ( logits ) elif mode == ClusteringMode . umap : reducer = umap . UMAP () clusters = reducer . fit_transform ( logits ) return clusters def plot ( self , logits : np . ndarray , images_paths : List [ Path ], timestamp : str , mode : ClusteringMode , ) -> Path : \"\"\"_summary_ Args: logits (np.ndarray): _description_ images_paths (List[Path]): _description_ timestamp (str): _description_ mode (ClusteringMode): _description_ Returns: Path: _description_ \"\"\" images_labels = [ Path ( image_path ) . parent . stem for image_path in images_paths ] labels_dict = { label : idx for idx , label in enumerate ( sorted ( set ( images_labels ))) } tags = [ labels_dict [ image_label ] for image_label in images_labels ] N = len ( set ( images_labels )) # define the colormap cmap = plt . cm . jet # extract all colors from the .jet map cmaplist = [ cmap ( i ) for i in range ( cmap . N )] # create the new map cmap = cmap . from_list ( \"Custom cmap\" , cmaplist , cmap . N ) plt . figure ( figsize = ( 20 , 20 )) scatter = plt . scatter ( logits [:, 0 ], logits [:, 1 ], c = tags , cmap = cmap ) if mode == ClusteringMode . tsne : plt . title ( \"tSNE scatterplot with ResNet50v2 preprocess\" ) if mode == ClusteringMode . umap : plt . title ( \"UMAP scatterplot with ResNet50v2 preprocess\" ) plt . xlabel ( \"Dimension 1\" ) plt . ylabel ( \"Dimension 2\" ) plt . legend ( handles = scatter . legend_elements ()[ 0 ], labels = sorted ( set ( images_labels )), title = \"Labels\" , ) saved_image_path = Path ( f \" { settings . scatterplots_dir } /tSNE_scatter_ { timestamp } .png\" , ) . resolve () plt . savefig ( saved_image_path ) return saved_image_path","title":"EmbeddingEngine"},{"location":"clustering/#app.dependancies.embedding_function.EmbeddingEngine.__init__","text":"summary Parameters: Name Type Description Default model EmbeddingsModel description required provider Providers description required Exceptions: Type Description NotImplementedError description NotImplementedError description Source code in app/dependancies/embedding_function.py def __init__ ( self , model : EmbeddingsModel , provider : Providers , * args , ** kwargs ) -> None : \"\"\"_summary_ Args: model (EmbeddingsModel): _description_ provider (Providers): _description_ Raises: NotImplementedError: _description_ NotImplementedError: _description_ \"\"\" super () . __init__ ( * args , ** kwargs ) if model == EmbeddingsModel . resnet50v2 : self . model = settings . resnet50v2 else : raise NotImplementedError if provider == Providers . cpu : self . provider = [ settings . cpu ] else : logger . warning ( \"GPU support not implemented, please chose cpu support.\" ) raise NotImplementedError self . loaded_model = rt . InferenceSession ( self . model , providers = self . provider )","title":"__init__()"},{"location":"clustering/#app.dependancies.embedding_function.EmbeddingEngine.compute_clustering","text":"summary Parameters: Name Type Description Default logits np.ndarray description required mode ClusteringMode description required Returns: Type Description np.ndarray description Source code in app/dependancies/embedding_function.py def compute_clustering ( self , logits : np . ndarray , mode : ClusteringMode , ) -> np . ndarray : \"\"\"_summary_ Args: logits (np.ndarray): _description_ mode (ClusteringMode): _description_ Returns: np.ndarray: _description_ \"\"\" if mode == ClusteringMode . tsne : clusters = TSNE ( n_components = 2 , learning_rate = \"auto\" , init = \"random\" , ) . fit_transform ( logits ) elif mode == ClusteringMode . umap : reducer = umap . UMAP () clusters = reducer . fit_transform ( logits ) return clusters","title":"compute_clustering()"},{"location":"clustering/#app.dependancies.embedding_function.EmbeddingEngine.infer","text":"summary Parameters: Name Type Description Default images_paths _type_ description required Returns: Type Description np.ndarray description Source code in app/dependancies/embedding_function.py def infer ( self , images_paths ) -> np . ndarray : \"\"\"_summary_ Args: images_paths (_type_): _description_ Returns: np.ndarray: _description_ \"\"\" images_list = [ Image . open ( image ) . resize (( 224 , 224 )) for image in images_paths ] images = [ np . asarray ( image , dtype = \"float32\" ) / 255 for image in images_list ] images = np . reshape ( images , ( - 1 , 224 , 224 , 3 )) logits = self . loaded_model . run ([ \"avg_pool\" ], { \"input\" : images }) return logits [ 0 ]","title":"infer()"},{"location":"clustering/#app.dependancies.embedding_function.EmbeddingEngine.plot","text":"summary Parameters: Name Type Description Default logits np.ndarray description required images_paths List[Path] description required timestamp str description required mode ClusteringMode description required Returns: Type Description Path description Source code in app/dependancies/embedding_function.py def plot ( self , logits : np . ndarray , images_paths : List [ Path ], timestamp : str , mode : ClusteringMode , ) -> Path : \"\"\"_summary_ Args: logits (np.ndarray): _description_ images_paths (List[Path]): _description_ timestamp (str): _description_ mode (ClusteringMode): _description_ Returns: Path: _description_ \"\"\" images_labels = [ Path ( image_path ) . parent . stem for image_path in images_paths ] labels_dict = { label : idx for idx , label in enumerate ( sorted ( set ( images_labels ))) } tags = [ labels_dict [ image_label ] for image_label in images_labels ] N = len ( set ( images_labels )) # define the colormap cmap = plt . cm . jet # extract all colors from the .jet map cmaplist = [ cmap ( i ) for i in range ( cmap . N )] # create the new map cmap = cmap . from_list ( \"Custom cmap\" , cmaplist , cmap . N ) plt . figure ( figsize = ( 20 , 20 )) scatter = plt . scatter ( logits [:, 0 ], logits [:, 1 ], c = tags , cmap = cmap ) if mode == ClusteringMode . tsne : plt . title ( \"tSNE scatterplot with ResNet50v2 preprocess\" ) if mode == ClusteringMode . umap : plt . title ( \"UMAP scatterplot with ResNet50v2 preprocess\" ) plt . xlabel ( \"Dimension 1\" ) plt . ylabel ( \"Dimension 2\" ) plt . legend ( handles = scatter . legend_elements ()[ 0 ], labels = sorted ( set ( images_labels )), title = \"Labels\" , ) saved_image_path = Path ( f \" { settings . scatterplots_dir } /tSNE_scatter_ { timestamp } .png\" , ) . resolve () plt . savefig ( saved_image_path ) return saved_image_path","title":"plot()"},{"location":"eda_functions/","text":"Source code of classical EDA functions app.dependancies.eda_functions compute_channels_mean ( image ) Compute the mean over each channels of an RGB images. Parameters: Name Type Description Default image np.ndarray The image, as a np.array, for which you want to compute the means. required Returns: Type Description Tuple[float, float, float] The RGB means. Source code in app/dependancies/eda_functions.py def compute_channels_mean ( image : np . ndarray ) -> Tuple [ float , float , float ]: \"\"\"Compute the mean over each channels of an RGB images. Args: image (np.ndarray): The image, as a np.array, for which you want to compute the means. Returns: Tuple[float, float, float]: The RGB means. \"\"\" red_mean_value = image [:, :, 0 ] . mean () green_mean_value = image [:, :, 1 ] . mean () blue_mean_value = image [:, :, 2 ] . mean () return red_mean_value , green_mean_value , blue_mean_value compute_channels_std ( image ) Compute the standard deviation over each channels of an RGB images. Parameters: Name Type Description Default image np.ndarray The image, as a np.array, for which you want to compute the stds. required Returns: Type Description Tuple[float, float, float] The RGB stds. Source code in app/dependancies/eda_functions.py def compute_channels_std ( image : np . ndarray ) -> Tuple [ float , float , float ]: \"\"\"Compute the standard deviation over each channels of an RGB images. Args: image (np.ndarray): The image, as a np.array, for which you want to compute the stds. Returns: Tuple[float, float, float]: The RGB stds. \"\"\" red_std_value = image [:, :, 0 ] . std () green_std_value = image [:, :, 1 ] . std () blue_std_value = image [:, :, 2 ] . std () return red_std_value , green_std_value , blue_std_value compute_histograms_channels ( image , filename , timestamp ) Compute the channels normed histograms of an image. The bins of the histograms are all of width 1, meaning that the normed histogram here defines a Probability mass function on each channels, i.e. the sum of all values for each channels is equal to 1. See the following StackOverflow post . Parameters: Name Type Description Default image np.ndarray The image, as a np.array, for which you want to compute the channels normed histograms. required filename str The name of the image file. required timestamp str The timestamp at which the endpoint has been called. required Returns: Type Description Path The path to the histogram. Source code in app/dependancies/eda_functions.py def compute_histograms_channels ( image : np . ndarray , filename : str , timestamp : str , ) -> Path : \"\"\"Compute the channels normed histograms of an image. The bins of the histograms are all of width 1, meaning that the normed histogram here defines a Probability mass function on each channels, i.e. the sum of all values for each channels is equal to 1. See the following [StackOverflow post](https://stackoverflow.com/questions/21532667/numpy-histogram-cumulative-density-does-not-sum-to-1). Args: image (np.ndarray): The image, as a np.array, for which you want to compute the channels normed histograms. filename (str): The name of the image file. timestamp (str): The timestamp at which the endpoint has been called. Returns: Path: The path to the histogram. \"\"\" colors = ( \"red\" , \"green\" , \"blue\" ) channel_ids = ( 0 , 1 , 2 ) pixel_range_value = 255 bins = np . arange ( 0 , pixel_range_value ) # create the histogram plot, with three lines, one for # each color plt . figure () plt . xlim ([ 0 , pixel_range_value ]) for channel_id , color in zip ( channel_ids , colors ): histogram , bin_edges = np . histogram ( image [:, :, channel_id ], bins = bins , range = ( 0 , pixel_range_value ), density = True , ) plt . plot ( bin_edges [ 0 : - 1 ], histogram , color = color ) plt . title ( f \"Color Histogram of { filename } \" ) plt . xlabel ( \"Color value\" ) plt . ylabel ( \"Pixel density\" ) saved_image_path = Path ( f \" { settings . histograms_dir } / { filename } _ { timestamp } .png\" , ) . resolve () plt . savefig ( saved_image_path ) return saved_image_path compute_mean_image ( images_list , timestamp ) Compute the mean image of an image dataset. Parameters: Name Type Description Default images_list List[np.ndarray] The image dataset on which you compute the mean image. required timestamp str The timestamp at which the endpoint has been called. required Returns: Type Description Path The path to the mean image. Source code in app/dependancies/eda_functions.py def compute_mean_image ( images_list : List [ np . ndarray ], timestamp : str ) -> Path : \"\"\"Compute the mean image of an image dataset. Args: images_list (List[np.ndarray]): The image dataset on which you compute the mean image. timestamp (str): The timestamp at which the endpoint has been called. Returns: Path: The path to the mean image. \"\"\" # Assuming all images are the same size, get dimensions of first image height , width , _ = images_list [ 0 ] . shape try : validate_height_width ( images_list = images_list ) except HeightWidthMismatchError as err : raise err num_images = len ( images_list ) # Create a numpy array of floats to store the average (assume RGB images) arr = np . zeros (( height , width , 3 ), dtype = np . float32 ) # Build up average pixel intensities arr = sum ( images_list ) / num_images # Round values in array and cast as 8-bit integer arr = np . array ( np . round ( arr ), dtype = np . uint8 ) # Generate, save final image out = Image . fromarray ( arr , mode = \"RGB\" ) saved_image_path = Path ( f \" { settings . mean_image_dir } /average_ { timestamp } .png\" , ) . resolve () out . save ( saved_image_path ) return saved_image_path compute_scatterplot ( images_paths , timestamp ) Compute the mean vs std scatterplot of an image dataset. Parameters: Name Type Description Default images_list List[np.ndarray] The image dataset on which you compute the mean vs std scatterplot. required timestamp str The timestamp at which the endpoint has been called. required Returns: Type Description Path The path to the scatterplot. Source code in app/dependancies/eda_functions.py def compute_scatterplot ( images_paths : List [ Path ], timestamp : str ) -> Path : \"\"\"Compute the mean vs std scatterplot of an image dataset. Args: images_list (List[np.ndarray]): The image dataset on which you compute the mean vs std scatterplot. timestamp (str): The timestamp at which the endpoint has been called. Returns: Path: The path to the scatterplot. \"\"\" # colors = (\"red\", \"green\", \"blue\") # channel_ids = (0, 1, 2) images_labels = [ Path ( image_path ) . parent . stem for image_path in images_paths ] labels_dict = { label : idx for idx , label in enumerate ( sorted ( set ( images_labels )))} tags = [ labels_dict [ image_label ] for image_label in images_labels ] images_list = [ np . array ( Image . open ( image ), dtype = np . float32 ) / 255 for image in images_paths ] # defines placeholders for subplots fig , ( ax1 , ax2 , ax3 ) = plt . subplots ( nrows = 1 , ncols = 3 , sharex = True , sharey = True , figsize = ( 20 , 15 ), ) fig . suptitle ( \"Mean-std scatterplot. Pixel values in [0,1]\" ) # fig = plt.figure(figsize=(20, 15)) # ax1 = fig.add_subplot(131) # ax2 = fig.add_subplot(132) # ax3 = fig.add_subplot(133) # compute means-stds for each subplots r_means = [ compute_channels_mean ( image )[ 0 ] for image in images_list ] r_stds = [ compute_channels_std ( image )[ 0 ] for image in images_list ] g_means = [ compute_channels_mean ( image )[ 1 ] for image in images_list ] g_stds = [ compute_channels_std ( image )[ 1 ] for image in images_list ] b_means = [ compute_channels_mean ( image )[ 2 ] for image in images_list ] b_stds = [ compute_channels_std ( image )[ 2 ] for image in images_list ] N = len ( set ( images_labels )) # define the colormap cmap = plt . cm . jet # extract all colors from the .jet map cmaplist = [ cmap ( i ) for i in range ( cmap . N )] # create the new map cmap = cmap . from_list ( \"Custom cmap\" , cmaplist , cmap . N ) # populate subplots ax1 . scatter ( r_means , r_stds , c = tags , alpha = 0.5 , cmap = cmap ) ax2 . scatter ( g_means , g_stds , c = tags , alpha = 0.5 , cmap = cmap ) ax3 . scatter ( b_means , b_stds , c = tags , alpha = 0.5 , cmap = cmap ) ax1 . set_title ( \"red channel\" ) ax1 . set_xlabel ( \"means\" ) ax1 . set_ylabel ( \"stds\" ) ax2 . set_title ( \"green channel\" ) ax2 . set_xlabel ( \"means\" ) ax2 . set_ylabel ( \"stds\" ) ax3 . set_title ( \"blue channel\" ) ax3 . set_xlabel ( \"means\" ) ax3 . set_ylabel ( \"stds\" ) handles , labels = ax3 . get_legend_handles_labels () fig . legend ( handles = handles , labels = labels , loc = \"upper left\" , ) # for channel, color in zip(channel_ids, colors): # means = [compute_channels_mean(image)[channel] for image in images_list] # stds = [compute_channels_std(image)[channel] for image in images_list] # plt.scatter(means, stds, c=color, alpha=0.5) # plt.title(\"Mean-std scatterplot. Pixel values in [0,1]\") # plt.xlabel(\"means\") # plt.ylabel(\"stds\") saved_image_path = Path ( f \" { settings . scatterplots_dir } /scatter_ { timestamp } .png\" , ) . resolve () plt . savefig ( saved_image_path ) return saved_image_path","title":"EDA Dependancies"},{"location":"eda_functions/#source-code-of-classical-eda-functions","text":"","title":"Source code of classical EDA functions"},{"location":"eda_functions/#app.dependancies.eda_functions","text":"","title":"eda_functions"},{"location":"eda_functions/#app.dependancies.eda_functions.compute_channels_mean","text":"Compute the mean over each channels of an RGB images. Parameters: Name Type Description Default image np.ndarray The image, as a np.array, for which you want to compute the means. required Returns: Type Description Tuple[float, float, float] The RGB means. Source code in app/dependancies/eda_functions.py def compute_channels_mean ( image : np . ndarray ) -> Tuple [ float , float , float ]: \"\"\"Compute the mean over each channels of an RGB images. Args: image (np.ndarray): The image, as a np.array, for which you want to compute the means. Returns: Tuple[float, float, float]: The RGB means. \"\"\" red_mean_value = image [:, :, 0 ] . mean () green_mean_value = image [:, :, 1 ] . mean () blue_mean_value = image [:, :, 2 ] . mean () return red_mean_value , green_mean_value , blue_mean_value","title":"compute_channels_mean()"},{"location":"eda_functions/#app.dependancies.eda_functions.compute_channels_std","text":"Compute the standard deviation over each channels of an RGB images. Parameters: Name Type Description Default image np.ndarray The image, as a np.array, for which you want to compute the stds. required Returns: Type Description Tuple[float, float, float] The RGB stds. Source code in app/dependancies/eda_functions.py def compute_channels_std ( image : np . ndarray ) -> Tuple [ float , float , float ]: \"\"\"Compute the standard deviation over each channels of an RGB images. Args: image (np.ndarray): The image, as a np.array, for which you want to compute the stds. Returns: Tuple[float, float, float]: The RGB stds. \"\"\" red_std_value = image [:, :, 0 ] . std () green_std_value = image [:, :, 1 ] . std () blue_std_value = image [:, :, 2 ] . std () return red_std_value , green_std_value , blue_std_value","title":"compute_channels_std()"},{"location":"eda_functions/#app.dependancies.eda_functions.compute_histograms_channels","text":"Compute the channels normed histograms of an image. The bins of the histograms are all of width 1, meaning that the normed histogram here defines a Probability mass function on each channels, i.e. the sum of all values for each channels is equal to 1. See the following StackOverflow post . Parameters: Name Type Description Default image np.ndarray The image, as a np.array, for which you want to compute the channels normed histograms. required filename str The name of the image file. required timestamp str The timestamp at which the endpoint has been called. required Returns: Type Description Path The path to the histogram. Source code in app/dependancies/eda_functions.py def compute_histograms_channels ( image : np . ndarray , filename : str , timestamp : str , ) -> Path : \"\"\"Compute the channels normed histograms of an image. The bins of the histograms are all of width 1, meaning that the normed histogram here defines a Probability mass function on each channels, i.e. the sum of all values for each channels is equal to 1. See the following [StackOverflow post](https://stackoverflow.com/questions/21532667/numpy-histogram-cumulative-density-does-not-sum-to-1). Args: image (np.ndarray): The image, as a np.array, for which you want to compute the channels normed histograms. filename (str): The name of the image file. timestamp (str): The timestamp at which the endpoint has been called. Returns: Path: The path to the histogram. \"\"\" colors = ( \"red\" , \"green\" , \"blue\" ) channel_ids = ( 0 , 1 , 2 ) pixel_range_value = 255 bins = np . arange ( 0 , pixel_range_value ) # create the histogram plot, with three lines, one for # each color plt . figure () plt . xlim ([ 0 , pixel_range_value ]) for channel_id , color in zip ( channel_ids , colors ): histogram , bin_edges = np . histogram ( image [:, :, channel_id ], bins = bins , range = ( 0 , pixel_range_value ), density = True , ) plt . plot ( bin_edges [ 0 : - 1 ], histogram , color = color ) plt . title ( f \"Color Histogram of { filename } \" ) plt . xlabel ( \"Color value\" ) plt . ylabel ( \"Pixel density\" ) saved_image_path = Path ( f \" { settings . histograms_dir } / { filename } _ { timestamp } .png\" , ) . resolve () plt . savefig ( saved_image_path ) return saved_image_path","title":"compute_histograms_channels()"},{"location":"eda_functions/#app.dependancies.eda_functions.compute_mean_image","text":"Compute the mean image of an image dataset. Parameters: Name Type Description Default images_list List[np.ndarray] The image dataset on which you compute the mean image. required timestamp str The timestamp at which the endpoint has been called. required Returns: Type Description Path The path to the mean image. Source code in app/dependancies/eda_functions.py def compute_mean_image ( images_list : List [ np . ndarray ], timestamp : str ) -> Path : \"\"\"Compute the mean image of an image dataset. Args: images_list (List[np.ndarray]): The image dataset on which you compute the mean image. timestamp (str): The timestamp at which the endpoint has been called. Returns: Path: The path to the mean image. \"\"\" # Assuming all images are the same size, get dimensions of first image height , width , _ = images_list [ 0 ] . shape try : validate_height_width ( images_list = images_list ) except HeightWidthMismatchError as err : raise err num_images = len ( images_list ) # Create a numpy array of floats to store the average (assume RGB images) arr = np . zeros (( height , width , 3 ), dtype = np . float32 ) # Build up average pixel intensities arr = sum ( images_list ) / num_images # Round values in array and cast as 8-bit integer arr = np . array ( np . round ( arr ), dtype = np . uint8 ) # Generate, save final image out = Image . fromarray ( arr , mode = \"RGB\" ) saved_image_path = Path ( f \" { settings . mean_image_dir } /average_ { timestamp } .png\" , ) . resolve () out . save ( saved_image_path ) return saved_image_path","title":"compute_mean_image()"},{"location":"eda_functions/#app.dependancies.eda_functions.compute_scatterplot","text":"Compute the mean vs std scatterplot of an image dataset. Parameters: Name Type Description Default images_list List[np.ndarray] The image dataset on which you compute the mean vs std scatterplot. required timestamp str The timestamp at which the endpoint has been called. required Returns: Type Description Path The path to the scatterplot. Source code in app/dependancies/eda_functions.py def compute_scatterplot ( images_paths : List [ Path ], timestamp : str ) -> Path : \"\"\"Compute the mean vs std scatterplot of an image dataset. Args: images_list (List[np.ndarray]): The image dataset on which you compute the mean vs std scatterplot. timestamp (str): The timestamp at which the endpoint has been called. Returns: Path: The path to the scatterplot. \"\"\" # colors = (\"red\", \"green\", \"blue\") # channel_ids = (0, 1, 2) images_labels = [ Path ( image_path ) . parent . stem for image_path in images_paths ] labels_dict = { label : idx for idx , label in enumerate ( sorted ( set ( images_labels )))} tags = [ labels_dict [ image_label ] for image_label in images_labels ] images_list = [ np . array ( Image . open ( image ), dtype = np . float32 ) / 255 for image in images_paths ] # defines placeholders for subplots fig , ( ax1 , ax2 , ax3 ) = plt . subplots ( nrows = 1 , ncols = 3 , sharex = True , sharey = True , figsize = ( 20 , 15 ), ) fig . suptitle ( \"Mean-std scatterplot. Pixel values in [0,1]\" ) # fig = plt.figure(figsize=(20, 15)) # ax1 = fig.add_subplot(131) # ax2 = fig.add_subplot(132) # ax3 = fig.add_subplot(133) # compute means-stds for each subplots r_means = [ compute_channels_mean ( image )[ 0 ] for image in images_list ] r_stds = [ compute_channels_std ( image )[ 0 ] for image in images_list ] g_means = [ compute_channels_mean ( image )[ 1 ] for image in images_list ] g_stds = [ compute_channels_std ( image )[ 1 ] for image in images_list ] b_means = [ compute_channels_mean ( image )[ 2 ] for image in images_list ] b_stds = [ compute_channels_std ( image )[ 2 ] for image in images_list ] N = len ( set ( images_labels )) # define the colormap cmap = plt . cm . jet # extract all colors from the .jet map cmaplist = [ cmap ( i ) for i in range ( cmap . N )] # create the new map cmap = cmap . from_list ( \"Custom cmap\" , cmaplist , cmap . N ) # populate subplots ax1 . scatter ( r_means , r_stds , c = tags , alpha = 0.5 , cmap = cmap ) ax2 . scatter ( g_means , g_stds , c = tags , alpha = 0.5 , cmap = cmap ) ax3 . scatter ( b_means , b_stds , c = tags , alpha = 0.5 , cmap = cmap ) ax1 . set_title ( \"red channel\" ) ax1 . set_xlabel ( \"means\" ) ax1 . set_ylabel ( \"stds\" ) ax2 . set_title ( \"green channel\" ) ax2 . set_xlabel ( \"means\" ) ax2 . set_ylabel ( \"stds\" ) ax3 . set_title ( \"blue channel\" ) ax3 . set_xlabel ( \"means\" ) ax3 . set_ylabel ( \"stds\" ) handles , labels = ax3 . get_legend_handles_labels () fig . legend ( handles = handles , labels = labels , loc = \"upper left\" , ) # for channel, color in zip(channel_ids, colors): # means = [compute_channels_mean(image)[channel] for image in images_list] # stds = [compute_channels_std(image)[channel] for image in images_list] # plt.scatter(means, stds, c=color, alpha=0.5) # plt.title(\"Mean-std scatterplot. Pixel values in [0,1]\") # plt.xlabel(\"means\") # plt.ylabel(\"stds\") saved_image_path = Path ( f \" { settings . scatterplots_dir } /scatter_ { timestamp } .png\" , ) . resolve () plt . savefig ( saved_image_path ) return saved_image_path","title":"compute_scatterplot()"},{"location":"utils/","text":"Source code of some utils functions app.dependancies.utils generate_batch ( lst , batch_size ) Yields batch of specified size Source code in app/dependancies/utils.py def generate_batch ( lst , batch_size ): \"\"\"Yields batch of specified size\"\"\" for i in range ( 0 , len ( lst ), batch_size ): yield lst [ i : i + batch_size ] get_items_list ( directory , extension ) The code above does the following: Creates a list of all the files in the directory. Applies a filter to the list to only include files with the given extension. Sorts the list by file name. Returns the list. Source code in app/dependancies/utils.py def get_items_list ( directory : str , extension : str ) -> List [ Path ]: \"\"\" The code above does the following: 1. Creates a list of all the files in the directory. 2. Applies a filter to the list to only include files with the given extension. 3. Sorts the list by file name. 4. Returns the list. \"\"\" return sorted ( Path ( file ) . absolute () for file in Path ( directory ) . glob ( f \"**/* { extension } \" ) if file . is_file () ) load_image_into_numpy_array ( data ) Load an image stored in bytes format in a numpy array. Parameters: Name Type Description Default data bytes The images stored in bytes format. required Returns: Type Description np.ndarray The np.array associated to the image. Source code in app/dependancies/utils.py def load_image_into_numpy_array ( data : bytes ) -> np . ndarray : \"\"\"Load an image stored in bytes format in a numpy array. Args: data (bytes): The images stored in bytes format. Returns: np.ndarray: The np.array associated to the image. \"\"\" return np . array ( Image . open ( BytesIO ( data ))) read_imagefile ( data ) Read an image stored in bytes format. Parameters: Name Type Description Default data bytes The images stored in bytes format. required Returns: Type Description Image.Image The read image. Source code in app/dependancies/utils.py def read_imagefile ( data : bytes ) -> Image . Image : \"\"\"Read an image stored in bytes format. Args: data (bytes): The images stored in bytes format. Returns: Image.Image: The read image. \"\"\" return Image . open ( BytesIO ( data ))","title":"Utils"},{"location":"utils/#source-code-of-some-utils-functions","text":"","title":"Source code of some utils functions"},{"location":"utils/#app.dependancies.utils","text":"","title":"utils"},{"location":"utils/#app.dependancies.utils.generate_batch","text":"Yields batch of specified size Source code in app/dependancies/utils.py def generate_batch ( lst , batch_size ): \"\"\"Yields batch of specified size\"\"\" for i in range ( 0 , len ( lst ), batch_size ): yield lst [ i : i + batch_size ]","title":"generate_batch()"},{"location":"utils/#app.dependancies.utils.get_items_list","text":"The code above does the following: Creates a list of all the files in the directory. Applies a filter to the list to only include files with the given extension. Sorts the list by file name. Returns the list. Source code in app/dependancies/utils.py def get_items_list ( directory : str , extension : str ) -> List [ Path ]: \"\"\" The code above does the following: 1. Creates a list of all the files in the directory. 2. Applies a filter to the list to only include files with the given extension. 3. Sorts the list by file name. 4. Returns the list. \"\"\" return sorted ( Path ( file ) . absolute () for file in Path ( directory ) . glob ( f \"**/* { extension } \" ) if file . is_file () )","title":"get_items_list()"},{"location":"utils/#app.dependancies.utils.load_image_into_numpy_array","text":"Load an image stored in bytes format in a numpy array. Parameters: Name Type Description Default data bytes The images stored in bytes format. required Returns: Type Description np.ndarray The np.array associated to the image. Source code in app/dependancies/utils.py def load_image_into_numpy_array ( data : bytes ) -> np . ndarray : \"\"\"Load an image stored in bytes format in a numpy array. Args: data (bytes): The images stored in bytes format. Returns: np.ndarray: The np.array associated to the image. \"\"\" return np . array ( Image . open ( BytesIO ( data )))","title":"load_image_into_numpy_array()"},{"location":"utils/#app.dependancies.utils.read_imagefile","text":"Read an image stored in bytes format. Parameters: Name Type Description Default data bytes The images stored in bytes format. required Returns: Type Description Image.Image The read image. Source code in app/dependancies/utils.py def read_imagefile ( data : bytes ) -> Image . Image : \"\"\"Read an image stored in bytes format. Args: data (bytes): The images stored in bytes format. Returns: Image.Image: The read image. \"\"\" return Image . open ( BytesIO ( data ))","title":"read_imagefile()"}]}